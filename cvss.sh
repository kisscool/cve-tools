#!/bin/sh
# vim: set softtabstop=2 shiftwidth=2 expandtab:
# (c) 2021 KissCool

# to enable/disable tracing
#set -xv
#set +xv

# directory of the script
topdir=`dirname "$(realpath $0)"`


getargs() {
  #if [ "$#" -eq 0 ] || [ "$1" = "-h"  ] || [ "$1" = "--help" ]
  #then
  #  usage
  #fi
  [ "$*" = "" ] && usage
  for i in $*; do
    case $i in
      cvss:3.1*|CVSS:3.1*)
        cvss_string=$i
        ;;
      *)
        usage
        ;;
    esac
  done
}

usage() {
  cat <<EOF
usage: $0 <CVSS string>

EOF
  exit 1
}

# check if the input is a valid CVSS string
# $1 : cvss_string to validate
# example : check_cvss_string_validity 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
check_cvss_string_validity() {
  echo -n "$1" | tr '[a-z]' '[A-Z]' | awk '
    BEGIN {RS="/"; FS=":"; mandatory=0}
    /^AV:[N,A,L,P]/ && tmp[$1]++ == 0 {mandatory++}
    /^AC:[L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^PR:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^UI:[N,R]/ && tmp[$1]++ == 0 {mandatory++}
    /^S:[U,C]/ && tmp[$1]++ == 0 {mandatory++}
    /^C:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^I:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^A:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    END {
      if (mandatory != 8) { exit 1 }
    }
  '
  [ $? != 0 ] && echo "Lack of mandatory metrics in CVSS string" && exit 1
}

# calculate CVSS scores
# $1 : cvss_string to calculate on
# example : calculate_cvss_score 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_cvss_score() {
  awk '
    # roundup function, as specified by CVSS specs (4.02 become 4.1 and 4.0 becomes 4)
    # number : floating number to roundup
    # example : roundup(4.02)
    function roundup(number) {
      # to make a round in awk : int(x+0.5)
      # to make a floor : int(x)
      int_input = int(number * 100000 + 0.5)
      if ((int_input % 10000) == 0) { return int_input / 100000.0 }
      else { return (int(int_input / 10000) +1) / 10.0 } 
    }

    # output the first value of the given metric in the CVSS string
    # output X (not defined) if the metric is not in the string
    # cvss : string to explore
    # metric : metric to find in the string
    # example cvss_value_in("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N", "AV")
    function cvss_value_in(cvss, metric) {
      split(cvss, metrics, "/")
      for (i in metrics) {
        if (match(metrics[i], "^"metric":")) {
          split (metrics[i], exploded_metric, ":")
          return exploded_metric[2]
        }
      }
      return "X"
    }
    
    # initialize a global array of CVSS numeric values
    # example : init_cvss_numeric()
    function init_cvss_numeric() {
      cvss_numeric["AV:N"] = 0.85
      cvss_numeric["AV:A"] = 0.62
      cvss_numeric["AV:L"] = 0.55
      cvss_numeric["AV:P"] = 0.2
      cvss_numeric["AC:L"] = 0.77
      cvss_numeric["AC:H"] = 0.44
      cvss_numeric["PR:N"] = 0.85
      cvss_numeric["PR:L"] = 0.62
      cvss_numeric["PR:H"] = 0.27
      cvss_numeric["PR_SC:N"] = 0.85
      cvss_numeric["PR_SC:L"] = 0.68
      cvss_numeric["PR_SC:H"] = 0.5
      cvss_numeric["UI:N"] = 0.85
      cvss_numeric["UI:R"] = 0.62
      cvss_numeric["S:U"] = 6.42
      cvss_numeric["S:C"] = 7.52
      cvss_numeric["C:N"] = 0
      cvss_numeric["C:L"] = 0.22
      cvss_numeric["C:H"] = 0.56
      cvss_numeric["I:N"] = 0
      cvss_numeric["I:L"] = 0.22
      cvss_numeric["I:H"] = 0.56
      cvss_numeric["A:N"] = 0
      cvss_numeric["A:L"] = 0.22
      cvss_numeric["A:H"] = 0.56
      cvss_numeric["E:X"] = 1
      cvss_numeric["E:U"] = 0.91
      cvss_numeric["E:P"] = 0.94
      cvss_numeric["E:F"] = 0.97
      cvss_numeric["E:H"] = 1
      cvss_numeric["RL:X"] = 1
      cvss_numeric["RL:O"] = 0.95
      cvss_numeric["RL:T"] = 0.96
      cvss_numeric["RL:W"] = 0.97
      cvss_numeric["RL:U"] = 1
      cvss_numeric["RC:X"] = 1
      cvss_numeric["RC:U"] = 0.92
      cvss_numeric["RC:R"] = 0.96
      cvss_numeric["RC:C"] = 1
      cvss_numeric["MAV:N"] = 0.85
      cvss_numeric["MAV:A"] = 0.62
      cvss_numeric["MAV:L"] = 0.55
      cvss_numeric["MAV:P"] = 0.2
      cvss_numeric["MAC:L"] = 0.77
      cvss_numeric["MAC:H"] = 0.44
      cvss_numeric["MPR:N"] = 0.85
      cvss_numeric["MPR:L"] = 0.62
      cvss_numeric["MPR:H"] = 0.27
      cvss_numeric["MPR_SC:N"] = 0.85
      cvss_numeric["MPR_SC:L"] = 0.68
      cvss_numeric["MPR_SC_H"] = 0.5
      cvss_numeric["MUI:N"] = 0.85
      cvss_numeric["MUI:R"] = 0.62
      cvss_numeric["MS:U"] = 6.42
      cvss_numeric["MS:C"] = 7.52
      cvss_numeric["MC:N"] = 0
      cvss_numeric["MC:L"] = 0.22
      cvss_numeric["MC:H"] = 0.56
      cvss_numeric["MI:N"] = 0
      cvss_numeric["MI:L"] = 0.22
      cvss_numeric["MI:H"] = 0.56
      cvss_numeric["MA:N"] = 0
      cvss_numeric["MA:L"] = 0.22
      cvss_numeric["MA:H"] = 0.56
      cvss_numeric["CR:X"] = 1
      cvss_numeric["CR:L"] = 0.5
      cvss_numeric["CR:M"] = 1
      cvss_numeric["CR:H"] = 1.5
      cvss_numeric["IR:X"] = 1
      cvss_numeric["IR:L"] = 0.5
      cvss_numeric["IR:M"] = 1
      cvss_numeric["IR:H"] = 1.5
      cvss_numeric["AR:X"] = 1
      cvss_numeric["AR:L"] = 0.5
      cvss_numeric["AR:M"] = 1
      cvss_numeric["AR:H"] = 1.5
    }

    # return the numeric value of a given metric in the CVSS string
    # base metrics : return nothing if the metric does not exist in the string (invalid string)
    # temporal and environmental metrics : return as if Not Defined (X value) if the metric does not exist in the string
    # cvss : string to explore
    # metric : metric to find in the CVSS string
    # example : cvss_numeric_in("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N", "AV")
    function cvss_numeric_in(cvss, metric) {
      value=cvss_value_in(cvss, metric)
      # take care of the modified but not defined metrics
      if (substr(metric,1,1) == "M" && value == "X") {
        metric=substr(metric,2)
        value=cvss_value_in(cvss, metric)
      }
      # take care of the special case of S:C for PR
      if (metric == "PR" && cvss_value_in(cvss, "S") == "C") {
        metric="PR_SC"
      }
      # take care of the special case of MS:C for MPR
      if (metric == "MPR" && cvss_value_in(cvss, "MS") == "C") {
        metric="MPR_SC"
      }
      return cvss_numeric[metric":"value]
    }

    # calculate the Impact sub-score
    # cvss : string to calculate on
    # example : calculate_iss("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_iss(cvss) {
      C=cvss_numeric_in(cvss, "C")
      I=cvss_numeric_in(cvss, "I")
      A=cvss_numeric_in(cvss, "A")
      return 1 - ((1-C)*(1-I)*(1-A))
    }

    # calculate the Impact score
    # cvss : string to calculate on
    # example : calculate_impact("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_impact(cvss) {
      iss=calculate_iss(cvss)
      s_value=cvss_value_in(cvss, "S")
      if (s_value == "U") { return 6.42 * iss }
      else { return 7.52 * (iss - 0.029) - 3.25 * ((iss - 0.02)^15) }
    }

    # calculate the Exploitability score
    # cvss : string to calculate on
    # example : calculate_exploitability("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_exploitability(cvss) {
      AV=cvss_numeric_in(cvss, "AV")
      AC=cvss_numeric_in(cvss, "AC")
      PR=cvss_numeric_in(cvss, "PR")
      UI=cvss_numeric_in(cvss, "UI")
      return 8.22 * AV * AC * PR * UI
    }

    # calculate BaseScore
    # cvss : string to calculate on
    # example : calculate_basescore("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_basescore(cvss) {
      impact=calculate_impact(cvss)
      if (impact <= 0) { return 0 }
      exploitability=calculate_exploitability(cvss)
      s_value=cvss_value_in(cvss, "S")
      if (s_value == "U") { score = impact + exploitability }
      else { score = 1.08 * (impact + exploitability) }
      if (score > 10) { score = 10 }
      return roundup(score)
    }

    # calculate TemporalScore
    # cvss : string to calculate on
    # example : calculate_temporalscore("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_temporalscore(cvss) {
      basescore=calculate_basescore(cvss)
      E=cvss_numeric_in(cvss, "E")
      RL=cvss_numeric_in(cvss, "RL")
      RC=cvss_numeric_in(cvss, "RC")
      return roundup(basescore * E * RL * RC)
    }

    # calculate the Modified Impact sub-score
    # cvss : string to calculate on
    # example : calculate_miss("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_miss(cvss) {
      CR=cvss_numeric_in(cvss, "CR")
      IR=cvss_numeric_in(cvss, "IR")
      AR=cvss_numeric_in(cvss, "AR")
      MC=cvss_numeric_in(cvss, "MC")
      MI=cvss_numeric_in(cvss, "MI")
      MA=cvss_numeric_in(cvss, "MA")
      score = 1 - ((1-CR*MC)*(1-IR*MC)*(1-AR*MA))
      if (score > 0.915) { score = 0.915 }
      return score
    }

    # calculate the Modified Impact score
    # cvss : string to calculate on
    # example : calculate_modifiedimpact("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_modifiedimpact(cvss) {
      miss=calculate_miss(cvss)
      ms_value=cvss_value_in(cvss, "MS")
      if (ms_value == "X") { ms_value=cvss_value_in(cvss, "S") }
      if (ms_value == "U") { return 6.42 * miss }
      else { return 7.52 * (miss - 0.029) - 3.25 * ((miss*0.9731 - 0.02)^13) }
    }

    # calculate the Modified Exploitability score
    # cvss : string to calculate on
    # example : calculate_modifiedexploitability("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_modifiedexploitability(cvss) {
      MAV=cvss_numeric_in(cvss, "MAV")
      MAC=cvss_numeric_in(cvss, "MAC")
      MPR=cvss_numeric_in(cvss, "MPR")
      MUI=cvss_numeric_in(cvss, "MUI")
      return 8.22 * MAV * MAC * MPR * MUI
    }

    # calculate EnvironmentalScore
    # cvss : string to calculate on
    # example : calculate_environmentalscore("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function calculate_environmentalscore(cvss) {
      modifiedimpact=calculate_modifiedimpact(cvss)
      if (modifiedimpact <= 0) { return 0 }
      modifiedexploitability=calculate_modifiedexploitability(cvss)
      ms_value=cvss_value_in(cvss, "MS")
      if (ms_value == "X") { ms_value=cvss_value_in(cvss, "S") }
      if (ms_value == "U") { score = modifiedimpact + modifiedexploitability }
      else { score = 1.08 * (modifiedimpact + modifiedexploitability) }
      if (score > 10) { score = 10 }
      E=cvss_numeric_in(cvss, "E")
      RL=cvss_numeric_in(cvss, "RL")
      RC=cvss_numeric_in(cvss, "RC")
      return roundup(roundup(score) * E* RL * RC)
    }

    # output verbose informations about the CVSS score
    # cvss : string to calculate on
    # example : verbose_score("CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N")
    function verbose_score(cvss) {
      printf("Base Score Metrics\n")
      printf("------------------\n")
      printf("%-40s %s\n", "Impact Sub-Score (ISS)", calculate_iss(cvss))
      printf("%-40s %s\n", "Impact", calculate_impact(cvss))
      printf("%-40s %s\n", "Exploitability", calculate_exploitability(cvss))
      printf("%-40s %s\n", "BaseScore", calculate_basescore(cvss))
      printf("\nTemporal Score Metrics\n")
      printf("----------------------\n")
      printf("%-40s %s\n", "TemporalScore", calculate_temporalscore(cvss))
      printf("\nEnvironmental Score Metrics\n")
      printf("---------------------------\n")
      printf("%-40s %s\n", "Modified Impact, Sub-Score (MISS)", calculate_miss(cvss))
      printf("%-40s %s\n", "ModifiedImpact", calculate_modifiedimpact(cvss))
      printf("%-40s %s\n", "ModifiedExploitability", calculate_modifiedexploitability(cvss))
      printf("%-40s %s\n", "EnvironmentalScore", calculate_environmentalscore(cvss))
    }

    BEGIN {
      init_cvss_numeric()
      cvss_string="'`echo -n "$1" | tr "[a-z]" "[A-Z]"`'"
      verbose_score(cvss_string)
    }
  '
}

############
# run things
getargs $*
check_cvss_string_validity $cvss_string
calculate_cvss_score $cvss_string

