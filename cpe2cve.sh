#!/bin/sh
# vim: set softtabstop=2 shiftwidth=2 expandtab:
# (c) 2024 KissCool

# various things always handy
topdir=`dirname "$(realpath $0)"`
progname=${0##*/}
horo=`date +'%y%m%d_%H%M'`


# default values for configurable options
setdefaults() {
  export verbose=${verbose:-0}
  export workdir=${workdir:-/tmp/cve.db}
  export resume=${resume:-0}
  export cutyear=${cutyear:-2020}
}


getargs() {
  [ "$#" -eq 0 ] && usage
  while getopts 'vw:xy:' opt; do
    case $opt in
      v)
        verbose=1
        ;;
      w)
        workdir="$OPTARG"
        ;;
      x)
        resume=1
        ;;
      y)
        cutyear="$OPTARG"
        ;;
      \?)
        usage
        ;;
      :)
        echo "Option -$OPTARG requires an argument."
        usage
        ;;
    esac
  done
  shift $(($OPTIND - 1))
  inputfile="$*"
  # if we are not in resume mode, we need an input file
  [ ${resume} -eq 0 -a "${inputfile}" = "" ] && usage
}


usage() {
  cat <<EOF
usage: 
  ${progname} [-v] [-w <workdir>] <file with CPE>
  ${progname} [-v] [-w <workdir>] -x

Options :
  -v          verbose
  -w <path>   working directory for current session (default: /tmp/cve.db)
  -x          resume last session
  -y <year>   cutoff year to filter old CVEs with often over-broad CPEs (default: 2020)
EOF
  exit 1
}


initdb() {
  # we create a directory hierarchy as a substitute for
  # associative arrays and such
  #Â we hit the cache most of the time, so performances are
  # surprisingly good
  export db="${workdir}"
  mkdir -p $db
  for i in input json tsv output; do
    mkdir -p $db/$i
    # if we are not in resume mode, we need a clean working directory
    [ ${resume} -eq 0 ] && find $db/$i -type f -delete
  done
  # if we are not in resume mode, we copy the input file
  [ ${resume} -eq 0 ] && cp ${inputfile} $db/input/input.tsv
}

# do a query to the (not very reliable) NVD API
# output a json response
query() {	
	cpe="$1"
	url="https://services.nvd.nist.gov/rest/json/cves/2.0?noRejected&cpeName=${cpe}"

  [ ${verbose} -eq 1 ] && echo "query : querying the NVD db about ${cpe}" >&2
  i=0
  while [ $i -lt 5 ]; do
    output=`curl -sS -w "\n%{http_code}" "${url}"`
    status=`echo "${output}" | awk 'END {print}'`
    body=`echo "${output}" | awk 'NR > 1 {print prev} {prev = $0}'`
    [ $status -eq 200 ] && break
    i=$(($i+1))
    sleep 5
  done
  [ $status -eq 200 ] && printf "%s" "${body}" > $db/json/${pkg}.json || (echo "query : while querying about ${cpe} NVD db replied with error ${status}. Body :" >&2;  echo "${body}" >&2)


#    [ $? -eq 0 ] || (echo "query : while querying about ${cpe} curl exited with return code $?" >&2; exit 1)
#    status=`echo "${output}" | awk 'END {print}'`
#    body=`echo "${output}" | awk 'NR > 1 {print prev} {prev = $0}'`
#    [ $status -eq 200 ] || (echo "query : while querying about ${cpe} NVD db replied with error ${status}. Body :" >&2 ; echo "${body}" >&2; exit 1)
#  
#  echo "${body}"
}

# parse the result of a NVD query
# output data formated in tsv format
parse() {
  pkg="$1"
  cpe="$2"
  
  [ ${verbose} -eq 1 ] && echo "parse : parsing the NVD results about ${cpe}" >&2
  cat | strings | sed 's#\\"##g; s#\\##g' | tr -d '\n\r\t' | jq -r '
    .vulnerabilities[] |
    select(.cve.published > "'${cutyear}'") |
    ["'${pkg}'", "'${cpe}'", .cve.id, .cve.metrics.cvssMetricV31[0].cvssData.baseScore, .cve.metrics.cvssMetricV31[0].cvssData.vectorString, "", "", .cve.descriptions[0].value] |
    @tsv
  '
}

# for a given CPE, output the associated CVEs in a tsv file
associatedcve() {
  pkg="$1"
  cpe="$2"
  
  # we could just pipe everything together, but temporary files are nicer for 
  # debugging and resuming session

  # if we are in resume mode, chances are high that json files already exists
  [ ! -f $db/json/${pkg}.json ] && query "${cpe}"
  cat $db/json/${pkg}.json | parse ${pkg} ${cpe} > $db/tsv/${pkg}.tsv
}

# iterate over a CPE listing to produce various tsv listings
listing2cve() {
  inputfile="$1"
  
  # we iterate over all lines, except for the header
  cat ${inputfile} | awk 'NR>1' | while read pkg cpe; do
    associatedcve ${pkg} ${cpe}
  done
}

# tally the various tsv listings in a single one
tallyresults() {
  # headers
  printf "Package\tCPE\tCVE\tBase_score\tBase_vector\tEnv_vector\tFinal_score\tDescription\n" > $db/output/cve_${horo}.tsv
  # we concatenate and sort everything
  cat $db/tsv/* | sort -k 1,3 | uniq >> $db/output/cve_${horo}.tsv
  echo "Final output is located in $db/output/cve_${horo}.tsv"
}


############
# run things
setdefaults
getargs $*
initdb
listing2cve $db/input/input.tsv
tallyresults


