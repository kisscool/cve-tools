#!/bin/sh
# vim: set softtabstop=2 shiftwidth=2 expandtab:
# (c) 2021 KissCool

# usage : 

# to enable/disable tracing
#set -xv
#set +xv

# directory of the script
topdir=`dirname "$(realpath $0)"`


getargs() {
  #if [ "$#" -eq 0 ] || [ "$1" = "-h"  ] || [ "$1" = "--help" ]
  #then
  #  usage
  #fi
  [ "$*" = "" ] && usage
  for i in $*; do
    case $i in
      cvss:3.1*|CVSS:3.1*)
        cvss_string=$i
        ;;
      *)
        usage
        ;;
    esac
  done
}

usage() {
  cat <<EOF
usage: $0 <CVSS string>

EOF
  exit 1
}

setdefaults() {
  export cvss_params="$topdir/cvss.json"
}

# roundup function, as specified by CVSS specs (4.02 -> 4.1 and 4.0 -> 4)
# $1 : floating number to roundup
#Â example : roundup 4.02
roundup() {
  # to make a round in awk : int(x+0.5)
  # to make a floor : int(x)
  awk '
    BEGIN {
      int_input = int('$1' * 100000 + 0.5)
      if ((int_input % 10000) == 0) { print int_input / 100000.0 }
      else { print (int(int_input / 10000) +1) / 10.0 }
    }
  '
}

# output the first value of the given metric in the CVSS string
# output X (not defined) if the metric is not in the string
# $1 : cvss_string to explore
# $2 : metric to find in the CVSS string
# example : cvss_value_in 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N' 'AV'
cvss_value_in() {
  metric=`echo -n "$2" | tr '[a-z]' '[A-Z]'`
  echo -n "$1" | tr '[a-z]' '[A-Z]' | awk '
    BEGIN {RS="/"; FS=":"; found_value=0}
    /CVSS/ {next}
    /^'$metric':/ {print $2; found_value=1; exit}
    END {
      if (!found_value) {print "X"}
    }
  '
}

# output the numeric value of a given CVSS metric:value
# output nothing if the metric:value couple does not exist
# $1 : metric_value to give the numeric value 
# example : cvss_numeric 'AV:N'
cvss_numeric() {
  metric_value=`echo -n "$1" | tr '[a-z]' '[A-Z]'`
  jq -c '.["'$metric_value'"]' $cvss_params
}

# output the numeric value of a given metric in the CVSS string
# base metrics : output nothing if the metric does not exist in the string (invalid string)
# temporal and environmental metrics : output as if Not Defined (X value) if the metric does not exist in the string
# $1 : cvss_string to explore
# $2 : metric to find in the CVSS string
# example : cvss_numeric_in 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N' 'AV'
cvss_numeric_in() {
  metric=`echo -n "$2" | tr '[a-z]' '[A-Z]'`
  value=`cvss_value_in $1 $metric`
  # take care of the modified but not defined metrics
  if [ `printf %.1s "$metric"` = "M" ] && [ $value = "X" ]; then
    metric=`echo -n "$metric" | awk '{print substr($1,2)}'`
    value=`cvss_value_in $1 $metric`
  fi
  # take care of the special case of S:C for PR
  [ $metric = "PR" ] && [ `cvss_value_in $1 "S"` = "C" ] && metric="PR_SC"
  # take care of the special case of MS:C for MPR
  [ $metric = "MPR" ] && [ `cvss_value_in $1 "MS"` = "C" ] && metric="MPR_SC"
  cvss_numeric $metric:$value
}

# check if the input is a valid CVSS string
# $1 : cvss_string to validate
# example : check_cvss_string_validity 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
check_cvss_string_validity() {
  echo -n "$1" | tr '[a-z]' '[A-Z]' | awk '
    BEGIN {RS="/"; FS=":"; mandatory=0}
    /^AV:[N,A,L,P]/ && tmp[$1]++ == 0 {mandatory++}
    /^AC:[L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^PR:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^UI:[N,R]/ && tmp[$1]++ == 0 {mandatory++}
    /^S:[U,C]/ && tmp[$1]++ == 0 {mandatory++}
    /^C:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^I:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    /^A:[N,L,H]/ && tmp[$1]++ == 0 {mandatory++}
    END {
      if (mandatory != 8) { exit 1 }
    }
  '
  [ $? != 0 ] && echo "Lack of mandatory metrics in CVSS string" && exit 1
}

# calculate the Impact sub-score
# $1 : cvss_string to calculate on
# example : calculate_iss 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_iss() {
  awk '
    BEGIN {
      C='`cvss_numeric_in $1 "C"`'
      I='`cvss_numeric_in $1 "I"`'
      A='`cvss_numeric_in $1 "A"`'
      print 1 - ((1-C)*(1-I)*(1-A))
    }
  '
}

# calculate the Impact score
# $1 : cvss_string to calculate on
# example : calculate_impact 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_impact() {
  awk '
    BEGIN {
      iss='`calculate_iss $1`'
      s_value="'`cvss_value_in $1 "S"`'"
      if (s_value == "U") { print 6.42 * iss }
      else { print 7.52 * (iss - 0.029) - 3.25 * ((iss - 0.02)^15) }
    }
  '
}

# calculate the Exploitability score
# $1 : cvss_string to calculate on
# example : calculate_exploitability 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_exploitability() {
  awk '
    BEGIN {
      AV='`cvss_numeric_in $1 "AV"`'
      AC='`cvss_numeric_in $1 "AC"`'
      PR='`cvss_numeric_in $1 "PR"`'
      UI='`cvss_numeric_in $1 "UI"`'
      print 8.22 * AV * AC * PR * UI
    }
  '
}

# calculate BaseScore
# $1 : cvss_string to calculate on
# example : calculate_basescore 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_basescore_before_roundup() {
  awk '
    BEGIN {
      impact='`calculate_impact $1`'
      if (impact <= 0) { print 0; exit }
      exploitability='`calculate_exploitability $1`'
      s_value="'`cvss_value_in $1 "S"`'"
      if (s_value == "U") { score = impact + exploitability }
      else { score = 1.08 * (impact + exploitability) }
      if (score > 10) { score = 10 }
      print score
    }
  '
}
calculate_basescore() {
  score=`calculate_basescore_before_roundup $1`
  roundup $score
}

# calculate TemporalScore
# $1 : cvss_string to calculate on
# example : calculate_temporalscore 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_temporalscore_before_roundup() {
  awk '
    BEGIN {
      basescore='`calculate_basescore $1`'
      E='`cvss_numeric_in $1 "E"`'
      RL='`cvss_numeric_in $1 "RL"`'
      RC='`cvss_numeric_in $1 "RC"`'
      print basescore * E * RL * RC
    }
  '
}
calculate_temporalscore() {
  score=`calculate_temporalscore_before_roundup $1`
  roundup $score
}

# calculate the Modified Impact sub-score
# $1 : cvss_string to calculate on
# example : calculate_miss 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_miss() {
  awk '
    BEGIN {
      CR='`cvss_numeric_in $1 "CR"`'
      IR='`cvss_numeric_in $1 "IR"`'
      AR='`cvss_numeric_in $1 "AR"`'
      MC='`cvss_numeric_in $1 "MC"`'
      MI='`cvss_numeric_in $1 "MI"`'
      MA='`cvss_numeric_in $1 "MA"`'
      score = 1 - ((1-CR*MC)*(1-IR*MC)*(1-AR*MA))
      if (score > 0.915) { score = 0.915 }
      print score
    }
  '
}

# calculate the Modified Impact score
# $1 : cvss_string to calculate on
# example : calculate_impact 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_modifiedimpact() {
  awk '
    BEGIN {
      miss='`calculate_miss $1`'
      ms_value="'`cvss_value_in $1 "MS"`'"
      if (ms_value == "X") { ms_value="'`cvss_value_in $1 "S"`'" }
      if (ms_value == "U") { print 6.42 * miss }
      else { print 7.52 * (miss - 0.029) - 3.25 * ((miss*0.9731 - 0.02)^13) }
    }
  '
}

# calculate the Modified Exploitability score
# $1 : cvss_string to calculate on
# example : calculate_exploitability 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_modifiedexploitability() {
  awk '
    BEGIN {
      MAV='`cvss_numeric_in $1 "MAV"`'
      MAC='`cvss_numeric_in $1 "MAC"`'
      MPR='`cvss_numeric_in $1 "MPR"`'
      MUI='`cvss_numeric_in $1 "MUI"`'
      print 8.22 * MAV * MAC * MPR * MUI
    }
  '
}

# calculate EnvironmentalScore
# $1 : cvss_string to calculate on
# example : calculate_environmentalscore 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
calculate_environmentalscore_before_roundup() {
  awk '
    BEGIN {
      modifiedimpact='`calculate_modifiedimpact $1`'
      if (modifiedimpact <= 0) { print 0; exit }
      modifiedexploitability='`calculate_modifiedexploitability $1`'
      ms_value="'`cvss_value_in $1 "MS"`'"
      if (ms_value == "X") { ms_value="'`cvss_value_in $1 "S"`'" }
      if (ms_value == "U") { score = modifiedimpact + modifiedexploitability }
      else { score = 1.08 * (modifiedimpact + modifiedexploitability) }
      if (score > 10) { score = 10 }
      print score
    }
  '
}
calculate_environmentalscore_with_temporal() {
  score=`calculate_environmentalscore_before_roundup $1`
  score=`roundup $score`
  awk '
    BEGIN {
      E='`cvss_numeric_in $1 "E"`'
      RL='`cvss_numeric_in $1 "RL"`'
      RC='`cvss_numeric_in $1 "RC"`'
      print '$score' * E * RL * RC
    }
  '

}
calculate_environmentalscore() {
  score=`calculate_environmentalscore_with_temporal $1`
  roundup $score
}



# output verbose informations about the CVSS score
# $1 : cvss_string to calculate on
# example : verbose_basescore 'cvss:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:N'
verbose_score() {
  printf "Base Score Metrics\n"
  echo "------------------"
  printf "%-40s %s\n" "Impact Sub-Score (ISS)" `calculate_iss $1`
  printf "%-40s %s\n" "Impact" `calculate_impact $1`
  printf "%-40s %s\n" "Exploitability" `calculate_exploitability $1`
  printf "%-40s %s\n" "BaseScore" `calculate_basescore $1`
  printf "\nTemporal Score Metrics\n"
  echo "----------------------"
  printf "%-40s %s\n" "TemporalScore" `calculate_temporalscore $1`
  printf "\nEnvironmental Score Metrics\n"
  echo "---------------------------"
  printf "%-40s %s\n" "Modified Impact Sub-Score (MISS)" `calculate_miss $1`
  printf "%-40s %s\n" "ModifiedImpact" `calculate_modifiedimpact $1`
  printf "%-40s %s\n" "ModifiedExploitability" `calculate_modifiedexploitability $1`
  printf "%-40s %s\n" "EnvironmentalScore" `calculate_environmentalscore $1`
}


############
# run things
getargs $*
setdefaults
check_cvss_string_validity $cvss_string
verbose_score $cvss_string


# dothings

# tip for logging
#(
# dothings
#) 2>&1 |tee -a  ${HOME}/$0.log
#
